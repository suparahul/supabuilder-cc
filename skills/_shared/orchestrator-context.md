# Supabuilder Orchestrator — Shared Context

This file is read by ALL `/supabuilder:*` skills for shared orchestration logic.

## Core Principle

Supabuilder is **project-agnostic**. Agents discover the project's tech stack, conventions, and patterns by reading:
- `.claude/supabuilder-context.md` (auto-generated by `/supabuilder:init`)
- `product_specs/_rules/` (user-maintained coding guidelines)
- The codebase itself (via Glob/Grep/Read)

Never assume a specific framework. Read before designing.

## Session Startup (All Skills)

Every skill starts by reading (skip any that don't exist):
1. `CLAUDE.md` (project context and instructions)
2. `.claude/supabuilder-context.md` (auto-generated: tech stack, structure, what's been built)
3. `.claude/supabuilder-state.json` (active sprints, cost mode, debate visibility)
4. `.claude/napkin.md` (project mistakes, corrections, patterns)
5. `product_specs/_rules/` (coding/tech guidelines)
6. `agents/supabuilder-shared-context.md` (agent ownership matrix, collaboration protocols)

## State Machine: Work Classification

When the user describes work, classify into **Rock / Pebble / Sand**:

| Size | Signals | Agents to Spawn |
|------|---------|-----------------|
| **Rock** | New module, major feature, cross-module impact | Strategist → PM → Designer → Architect → TechPM → Dev Swarm → QA |
| **Pebble** | Enhancement, new screen, contained scope | PM → Designer → Architect → TechPM → Dev → QA |
| **Sand** | Bug fix, copy change, minor tweak | Direct to Dev or Designer → QA |

## Agent Spawn Protocol

**Spawn agents progressively — never all at once.**

**Directory Creation:** When spawning PM for a new feature, create `product_specs/{module}/` if it doesn't exist. PM determines if module is single-feature (specs here) or multi-feature (create feature subdirs).

1. **PM first** — Define requirements. PM uses AskUserQuestion to deeply engage with user. PM creates /sketch diagrams for complex flows.
2. **Designer next** — When PM requirements solidify. Designer creates 2-3 variations with HTML prototypes (`.claude/scratchpad/`) and Excalidraw diagrams (`/sketch`). User reviews in browser.
3. **Architect next** — When design is chosen. Architect reads codebase to follow existing patterns. Creates architecture diagrams with /sketch. Designs for the project's actual tech stack.
4. **TechPM next** — When architecture is locked. Creates tickets in Linear (if configured) or markdown. Defines parallel dev waves.
5. **Dev Build** — When tickets ready and user says "build" (via `/supabuilder:develop`). Orchestrator creates a team of `general-purpose` agents (not `dev` agents — those are review-only). Each builder works in an isolated worktree. Waves execute sequentially; tickets within a wave run in parallel. Incremental QA after each wave gates the next.
6. **Dev Review + QA** — After build (via `/supabuilder:review`). The `dev` agent type reviews code against spec (read-only). The `qa` agent tests as real user. Both route findings back to spec owners.

## Dev Swarm Protocol (`/supabuilder:develop`)

For Rock-sized work, implementation happens via `/supabuilder:develop` in sequential waves with incremental QA:

1. **TechPM defines waves** — Groups of tickets that can run simultaneously (Wave 1: foundation, Wave 2: core, Wave 3: integration)
2. **Orchestrator creates team** — `TeamCreate` with name `"build-{feature-name}"`. The orchestrator coordinates directly — no separate TechPM agent in the build team.
3. **Wave execution loop** (sequential waves, parallel tickets within each wave):
   - **Spawn dev builders** — `subagent_type: "general-purpose"` with `isolation: "worktree"`. One per ticket, all in a wave run in parallel.
   - **Wait for wave completion** — All dev agents in the wave must finish.
   - **Incremental QA** — `subagent_type: "qa"` tests ONLY this wave's tickets (not full feature). Verifies ACs, lint, build, file manifest.
   - **Gate next wave** — Blocking findings must be fixed (spawn fix-dev agent) before proceeding. Non-blocking findings are logged.
4. **Post-build** → Summary of waves, tickets, QA results. Offer `/supabuilder:review` for comprehensive code review + full QA.

**Why `general-purpose` not `dev`:** The `dev` agent type is review-only (no Edit/Write/Bash). Dev builders need full tool access. Build instructions are contextual per-feature and live in the `/supabuilder:develop` skill prompt. The `dev` agent type is used during `/supabuilder:review` for post-build code review.

## Agent Interaction Protocol

**Agents must deeply engage with the user.** They are not transcribers — they are thought partners.

- **Use AskUserQuestion extensively** — Don't guess. Ask. Present 2-3 options with clear tradeoffs and a recommendation.
- **Push back** — If a requirement is vague, challenge it. If a design is bad UX, say so. If architecture won't scale, flag it.
- **Diagram first, spec second** — Every agent creates Excalidraw diagrams as a primary output before or alongside spec prose. PMs diagram user journeys before writing FRs. Designers diagram each variation before writing flows. Architects diagram the system before writing technical specs. Diagrams are referenced at the top of spec sections — the prose explains what the diagram shows. See the Visual-First Protocol in `agents/supabuilder-shared-context.md` for naming conventions and the full agent diagram responsibility matrix.
- **Designer creates HTML prototypes** — Lightweight, self-contained HTML/CSS/JS files in `.claude/scratchpad/` that users open in their browser to experience designs before they're built.
- **Collaborate via SendMessage** — Agents debate, challenge, and build on each other's work. PM ↔ Designer for UX tradeoffs. PM ↔ Architect for feasibility. Dev → Architect for spec mismatches. QA → PM for spec gaps.

## State File Structure

`.claude/supabuilder-state.json`:

```json
{
  "active_sprints": [
    {
      "id": "sprint-{feature-name}",
      "name": "Feature Name",
      "size": "rock|pebble|sand",
      "phase": "requirements|design|architecture|tickets|building|review|testing|revising|complete",
      "agents_active": ["pm", "designer"],
      "started": "2026-02-23T17:00:00Z",
      "build_state": {
        "team_name": "build-{feature-name}",
        "current_wave": 2,
        "total_waves": 3,
        "completed_waves": [1],
        "tickets_completed": ["TICK-001", "TICK-002"],
        "tickets_remaining": ["TICK-003", "TICK-004", "TICK-005"],
        "qa_results": {
          "1": { "result": "pass", "blocking": 0, "non_blocking": 1 }
        }
      }
    }
  ],
  "cost_mode": "smart",
  "debate_visibility": "key_decisions"
}
```

The `build_state` sub-object is present only when `phase` is `"building"`. It tracks wave progress, ticket completion, and per-wave QA results. The `/supabuilder:develop` skill manages this state; `/supabuilder:status` reads it for progress display.

## MCP Integration

During `/supabuilder:init`, offer optional setup:
- **Linear**: For ticket tracking. TechPM uses `mcp__linear__create_issue`, `mcp__linear__update_issue`, etc.
- **Reddit**: For community research. Strategist uses `mcp__reddit-mcp-buddy__search_reddit` etc.

If skipped, system falls back gracefully:
- No Linear → TechPM creates markdown tickets in `product_specs/{module}/tickets.md` + `product_specs/{module}/tickets/wave_N.md`
- No Reddit → Strategist uses WebSearch instead

## Decision Points

Use **AskUserQuestion** at every key moment:
- **Size classification**: "This sounds like a Rock — new module with cross-cutting impact. Does that match?"
- **Design choice**: Present 2-3 variations with markdown previews
- **Technical tradeoffs**: "Option A is simpler but limited. Option B scales but adds complexity."
- **Scope gates**: "Ready for design?" / "Architecture approved?" / "Ready to build?"

## Cost Modes

Read from `.claude/supabuilder-state.json` field `cost_mode`:
- `quality`: All agents use Opus. 5 debate rounds max.
- `smart` (default): Opus for PM/Designer/Strategist/Architect. Sonnet for TechPM/QA/Dev. 3 rounds.
- `budget`: Sonnet for all. 1 round (no debate).

Dev builder agents (spawned by `/supabuilder:develop`) follow the same cost mode rules as Dev/QA — Sonnet in `smart` mode, Opus in `quality` mode.

## Debate Visibility

Read from `.claude/supabuilder-state.json` field `debate_visibility`:
- `key_decisions` (default): Agents debate privately. Surface 2-3 options at decision points.
- `show_all`: All agent-to-agent messages visible to user.
- `summaries_only`: Agents agree internally, present final recommendation.

## File Ownership & Protocols

See `agents/supabuilder-shared-context.md` for:
- Complete ownership matrix (which agent writes which files)
- Feedback routing protocol (QA → PM, Dev → Architect, etc.)
- Collaboration pair details
- Output standards and announcement format
